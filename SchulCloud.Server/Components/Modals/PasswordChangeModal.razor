@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Identity
@using Microsoft.Extensions.Localization
@using SchulCloud.Database.Models
@using SchulCloud.Server.Extensions
@using SchulCloud.Server.Models
@using System.Security.Claims

@implements IAsyncDisposable

@inject IStringLocalizer<PasswordChangeModal> _localizer
@inject IPasswordValidator<User> _passwordValidator
@inject UserManager<User> _userManager
@inject IdentityErrorDescriber _errorDescriber
@inject ToastService _toastService

<Modal @ref="Modal" Title="@_localizer["modalTitle"]" HeaderCssClass="bg-body text-light-emphasis" ShowCloseButton="false" UseStaticBackdrop>
    <BodyTemplate>
        <EditForm EditContext="_editContext">
            <div class="input-group has-validation mb-3">
                <div class="form-floating@(IsInvalid(nameof(Model.CurrentPassword)))">
                    @{
                        string inputType = _passwordVisible ? "text" : "password";
                    }
                    <input type="@inputType" class="form-control rounded-end-0@(IsInvalid(nameof(Model.CurrentPassword)))" id="floatingPassword" @bind="Model.CurrentPassword" placeholder="password" autocomplete="current-password" required />
                    <label for="floatingPassword">@_localizer["currentPassword_Placeholder"]</label>
                </div>

                <span class="input-group-text p-0">
                    <Button Class="d-flex align-items-center" @onclick="@(() => _passwordVisible = !_passwordVisible)">
                        @{
                            string iconName = _passwordVisible ? "visibility" : "visibility_off";
                        }
                        <FontsIcon Name="@iconName" />
                    </Button>
                </span>

                <ValidationMessage For="() => Model.CurrentPassword" AdditionalAttributes="@(new Dictionary<string, object>(){{"class", "invalid-feedback"}})" />
            </div>

            <div class="input-group has-validation mb-3">
                <div class="form-floating@(IsInvalid(nameof(Model.NewPassword)))">
                    @{
                        string newPwdInputType = _newPasswordVisible ? "text" : "password";
                    }
                    <input type="@newPwdInputType" class="form-control rounded-end-0@(IsInvalid(nameof(Model.NewPassword)))" id="floatingPassword" @bind="Model.NewPassword" placeholder="newPassword" autocomplete="new-password" required />
                    <label for="floatingPassword">@_localizer["newPassword_Placeholder"]</label>
                </div>

                <span class="input-group-text p-0">
                    <Button Class="d-flex align-items-center" @onclick="@(() => _newPasswordVisible = !_newPasswordVisible)">
                        @{
                            string iconName = _newPasswordVisible ? "visibility" : "visibility_off";
                        }
                        <FontsIcon Name="@iconName" />
                    </Button>
                </span>

                <ValidationMessage For="() => Model.NewPassword" AdditionalAttributes="@(new Dictionary<string, object>(){{"class", "invalid-feedback"}})" />
            </div>

            <div class="input-group has-validation">
                <div class="form-floating@(IsInvalid(nameof(Model.ConfirmedPassword)))">
                    @{
                        string confirmedPwdInputType = _confirmedPasswordVisible ? "text" : "password";
                    }
                    <input type="@confirmedPwdInputType" class="form-control rounded-end-0@(IsInvalid(nameof(Model.ConfirmedPassword)))" id="floatingPassword" @bind="Model.ConfirmedPassword" placeholder="newPassword" autocomplete="confirmed-password" required />
                    <label for="floatingPassword">@_localizer["confirmedPassword_Placeholder"]</label>
                </div>

                <span class="input-group-text p-0">
                    <Button Class="d-flex align-items-center" @onclick="@(() => _confirmedPasswordVisible = !_confirmedPasswordVisible)">
                        @{
                            string iconName = _confirmedPasswordVisible ? "visibility" : "visibility_off";
                        }
                        <FontsIcon Name="@iconName" />
                    </Button>
                </span>

                <ValidationMessage For="() => Model.ConfirmedPassword" AdditionalAttributes="@(new Dictionary<string, object>(){{"class", "invalid-feedback"}})" />
            </div>
        </EditForm>
    </BodyTemplate>
    <FooterTemplate>
        <Button Color="ButtonColor.Secondary" @onclick="CloseModal_ClickAsync">@_localizer["abort"]</Button>
        <Button Color="ButtonColor.Primary" @onclick="ChangePassword_ClickAsync">@_localizer["submit"]</Button>
    </FooterTemplate>
</Modal>

@code {
    private bool _passwordVisible = false;

    private bool _newPasswordVisible = false;

    private bool _confirmedPasswordVisible = false;

    private EditContext _editContext = default!;

    private ValidationMessageStore _messageStore = default!;

    private User _user = default!;

    public Modal Modal { get; set; } = default!;

    public PasswordChangeModel Model { get; set; } = new();

    [CascadingParameter]
    public Task<AuthenticationState> AuthenticationState { get; set; } = default!;

    protected override void OnInitialized()
    {
        _editContext = new(Model);
        _messageStore = new(_editContext);
        _editContext.OnValidationRequested += OnValidationRequest;
    }

    protected override async Task OnInitializedAsync()
    {
        AuthenticationState state = await AuthenticationState.ConfigureAwait(false);
        _user = (await _userManager.GetUserAsync(state.User).ConfigureAwait(false))!;
    }

    private async void OnValidationRequest(object? sender, ValidationRequestedEventArgs e)
    {
        _messageStore.Clear();

        if (!await _userManager.CheckPasswordAsync(_user, Model.CurrentPassword).ConfigureAwait(false))
        {
            FieldIdentifier identifier = _editContext.Field(nameof(Model.CurrentPassword));
            _messageStore.Add(identifier, _errorDescriber.PasswordMismatch().Description);

            goto validationEnd;
        }

        IdentityResult newPwdResult = await _passwordValidator.ValidateAsync(_userManager, _user, Model.NewPassword).ConfigureAwait(false);
        if (!newPwdResult.Succeeded)
        {
            FieldIdentifier identifier = _editContext.Field(nameof(Model.NewPassword));
            foreach (IdentityError error in newPwdResult.Errors)
            {
                _messageStore.Add(identifier, error.Description);
            }

            goto validationEnd;
        }

        if (!Model.ConfirmedPassword.Equals(Model.NewPassword))
        {
            FieldIdentifier identifier = _editContext.Field(nameof(Model.ConfirmedPassword));
            _messageStore.Add(identifier, _localizer["confirmedPassword_DoesNotMatch"]);
        }

        validationEnd:
        _editContext.NotifyValidationStateChanged();
    }

    private string IsInvalid(string fieldName)
    {
        FieldIdentifier identifier = _editContext.Field(fieldName);
        if (!_editContext.IsValid(identifier))
        {
            return " is-invalid";
        }

        return string.Empty;
    }

    private async Task CloseModal_ClickAsync()
    {
        await Modal.HideAsync().ConfigureAwait(false);
    }

    private async Task ChangePassword_ClickAsync()
    {
        if (_editContext.Validate())
        {
            IdentityResult result = await _userManager.ChangePasswordAsync(_user, Model.CurrentPassword, Model.NewPassword).ConfigureAwait(true);     // The original context is required here because the ToastService needs a synchronized context.
            if (result.Succeeded)
            {
                Model = new();

                _toastService.NotifySuccess(_localizer["successToast_Title"], _localizer["successToast_Message"]);
                await Modal.HideAsync().ConfigureAwait(false);
            }
            else
            {
                _toastService.NotifyError(result.Errors, _localizer["errorToast_Title"]);
            }
        }
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        await Modal.DisposeAsync().ConfigureAwait(false);
    }
}
