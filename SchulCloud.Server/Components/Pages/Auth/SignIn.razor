@using Humanizer
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.DataProtection
@using Microsoft.AspNetCore.Identity
@using Microsoft.Extensions.Localization
@using SchulCloud.Database.Models
@using SchulCloud.Server.Enums
@using SchulCloud.Server.Models
@using SchulCloud.Server.Utils.Interfaces
@using System.Security.Claims

@implements IDisposable

@page "/auth/signIn"
@rendermode InteractiveServer

@attribute [AllowAnonymous]

@inject ILogger<SignIn> _logger
@inject IStringLocalizer<SignIn> _localizer
@inject IRequestState _state
@inject SignInManager<User> _signInManager
@inject UserManager<User> _userManager
@inject NavigationManager _navigationManager
@inject PersistentComponentState _componentState;

<SchulCloudPageTitle Title="@_localizer["title"]" />

<HeadContent>
    <style>
        input.is-invalid {
            background-image: none !important;
        }

        div.input-group.pwd-group {
            margin-top: -1px;
        }

        input[name="@($"{nameof(Model)}.{nameof(Model.User)}")"].is-invalid {
            border-bottom-color: var(--bs-border-color) !important;
        }

        input[name="@($"{nameof(Model)}.{nameof(Model.Password)}")"].is-invalid {
            border-top-color: var(--bs-border-color) !important;
            border-right-color: var(--bs-border-color) !important;
        }

        .pwd-group span.is-invalid {
            border-right-color: var(--bs-form-invalid-border-color) !important;
            border-bottom-color: var(--bs-form-invalid-border-color) !important;
        }
    </style>
</HeadContent>

<div class="container py-5 my-5">
    <div class="row mb-2">
        <div class="col" />
        <div class="col-6">
            <h3>@_localizer["formHeader"]</h3>
        </div>
        <div class="col" />
    </div>
    <div class="row">
        <div class="col" />
        <div class="col-6">
            <form @formname="signIn" method="post" action="@_navigationManager.Uri">
                <input type="hidden" name="_handler" value="signIn" />     @* I have to place this hidden field by manual because in interactive SSR Blazor doesn't place it by its own. *@
                <AntiforgeryToken />

                <div class="input-group">
                    <div class="form-floating@(IsInvalid())">
                        <input type="text" name="@($"{nameof(Model)}.{nameof(Model.User)}")" class="form-control rounded-bottom-0@(IsInvalid())" id="floatingUsername" @bind="Model.User" @bind:after="Input_Changed" placeholder required />
                        <label for="floatingUsername">@_localizer["formUserPlaceholder"]</label>
                    </div>
                </div>

                <div class="input-group pwd-group has-validation">
                    <div class="form-floating@(IsInvalid())">
                        @{
                            string inputType = _passwordVisible ? "text" : "password";
                        }
                        <input type="@inputType" name="@($"{nameof(Model)}.{nameof(Model.Password)}")" class="form-control rounded-top-0@(IsInvalid())" id="floatingPassword" @bind="Model.Password" @bind:after="Input_Changed" placeholder autocomplete="off" required />
                        <label for="floatingPassword">@_localizer["formPasswordPlaceholder"]</label>
                    </div>

                    <span class="input-group-text rounded-top-0 p-0@(IsInvalid())">
                        <Button Class="d-flex align-items-center" @onclick="PasswordVisible_Click">
                            @{
                                string iconName = _passwordVisible ? "visibility" : "visibility_off";
                            }
                            <FontsIcon Name="@iconName" />
                        </Button>
                    
                    </span>
                    <div class="invalid-feedback">@_errorMessage</div>
                </div>

                <div class="form-check my-3">
                    <InputCheckbox name="@($"{nameof(Model)}.{nameof(Model.RememberMe)}")" class="form-check-input" @bind-Value="Model.RememberMe" id="rememberMe" />
                    <label class="form-check-label" for="rememberMe">@_localizer["formPersistent"]</label>
                </div>

                <Button Class="w-100" Color="ButtonColor.Primary" Type="ButtonType.Submit">@_localizer["formSubmit"]</Button>
            </form>
        </div>
        <div class="col" />
    </div>
</div>

@code {
    private bool _passwordVisible = false;

    private string? _errorMessage;

    private PersistingComponentStateSubscription? _persistingSubscription;

    [CascadingParameter]
    private HttpContext? HttpContext { get; set; }

    [CascadingParameter]
    private Task<AuthenticationState> AuthenticationState { get; set; } = default!;

    [SupplyParameterFromQuery(Name = "returnUrl")]
    public string? ReturnUrl { get; set; }

    [SupplyParameterFromForm]
    public SignInModel Model { get; set; } = new();

    protected override async Task OnInitializedAsync()
    {
        // Make sure that every auth cookie is cleaned up if present.
        AuthenticationState state = await AuthenticationState.ConfigureAwait(false);
        if (_signInManager.IsSignedIn(state.User))
        {
            if (HttpContext is null)
            {
                _navigationManager.Refresh(forceReload: true);
                return;
            }

            await _signInManager.SignOutAsync().ConfigureAwait(false);
        }

        string? method = HttpContext?.Request.Method;
        if (HttpContext is not null && HttpMethods.IsPost(method!))
        {
            await SignInAsync().ConfigureAwait(false);

            _persistingSubscription = _componentState.RegisterOnPersisting(() =>
            {
                _componentState.PersistAsJson(nameof(Model), Model);
                _componentState.PersistAsJson(nameof(_errorMessage), _errorMessage);

                return Task.CompletedTask;
            });
        }
        else
        {
            if (_componentState.TryTakeFromJson(nameof(Model), out SignInModel? persistingModel))
            {
                Model = persistingModel!;
            }
            _componentState.TryTakeFromJson(nameof(_errorMessage), out _errorMessage);
        }
    }

    private async Task SignInAsync()
    {
        User? user = await _userManager.FindByEmailAsync(Model.User).ConfigureAwait(false);
        user ??= await _userManager.FindByNameAsync(Model.User).ConfigureAwait(false);

        if (user is null)
        {
            _errorMessage = _localizer["signIn_" + SignInResult.Failed];
            return;
        }

        SignInResult result = await _signInManager.PasswordSignInAsync(user, Model.Password, Model.RememberMe, lockoutOnFailure: true).ConfigureAwait(false);

        switch (result)
        {
            case { Succeeded: true }:
                Uri returnUri = _navigationManager.ToAbsoluteUri(ReturnUrl);
                _navigationManager.NavigateTo(returnUri.PathAndQuery);     // prevent a redirect to another domain by using only the path and query part.
                break;
            case { RequiresTwoFactor: true }:
                throw new NotImplementedException("Mfa is currently not implemented.");
                break;
            case { IsLockedOut: true }:
                DateTimeOffset lockOutEnd = (await _userManager.GetLockoutEndDateAsync(user).ConfigureAwait(false)).Value;

                _errorMessage = lockOutEnd < DateTimeOffset.MaxValue     // MaxValue means that the user is locked without an end. It has to unlocked manually.
                    ? _localizer["signIn_LockedOut", lockOutEnd.Humanize()]
                    : _localizer["signIn_LockedOut_NotSpecified"];
                break;
            default:
                _errorMessage = _localizer["signIn_" + result];
                break;
        }
    }

    private void Input_Changed()
    {
        _errorMessage = null;
    }

    private void PasswordVisible_Click()
    {
        _passwordVisible = !_passwordVisible;
    }

    private string IsInvalid()
    {
        if (_errorMessage is not null)
        {
            return " is-invalid";
        }
        return string.Empty;
    }

    void IDisposable.Dispose()
    {
        _persistingSubscription?.Dispose();
    }
}
