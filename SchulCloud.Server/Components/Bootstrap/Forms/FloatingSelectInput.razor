@typeparam TValue
@inherits FloatingInputBase<TValue>

<div class="@ClassNames" style="@StyleNames">
    <select class="@($"{ExtendedBootstrapClass.FormSelect} {FieldCssClass}".Trim())" id="@Id" @onchange="OnSelectionChangedAsync" @attributes="AdditionalAttributes">
        @if (DefaultTemplate is not null)
        {
            <option @attributes="@([ new KeyValuePair<string, object>("selected", Value is null) ])" disabled>
                @DefaultTemplate
            </option>
        }

        @foreach (TValue value in Values)
        {
            IEnumerable<KeyValuePair<string, object>> attributes =
            [
                new KeyValuePair<string, object>("selected", value!.Equals(Value)!),
                new KeyValuePair<string, object>("disabled", DisabledValues.Contains(value))
            ];
            <option value="@IdSelector(value)" @attributes="attributes">
                @if (ItemTemplate is not null)
                {
                    @ItemTemplate(value)
                }
                else
                {
                    @value?.ToString()
                }
            </option>
        }
    </select>
    <label for="@Id">@FloatingLabel</label>

    @if (ShowValidationFeedback)
    {
        <BsValidationFeedback Identifier="_fieldIdentifier" />
    }
</div>

@code {
    /// <summary>
    /// Values to show as an options
    /// </summary>
    [Parameter]
    public required IEnumerable<TValue> Values { get; set; }

    /// <summary>
    /// Values to disable.
    /// </summary>
    /// <remarks>
    /// Every value that this contains also have to be contained in <see cref="Values"/>
    /// </remarks>
    [Parameter]
    public IEnumerable<TValue> DisabledValues { get; set; } = [];

    /// <summary>
    /// Specifies a selector that is used to determine a unique id of the item
    /// </summary>
    /// <remarks>
    /// By default is <see cref="TValue.ToString"/> used.
    /// </remarks>
    [Parameter]
    public Func<TValue, string> IdSelector { get; set; } = default!;

    /// <summary>
    /// Specifies a default template that will be shown when no item is selected (<see cref="Value"/> is <c>null</c>).
    /// </summary>
    /// <remarks>
    /// This item isn't selectable.
    /// </remarks>
    [Parameter]
    public RenderFragment? DefaultTemplate { get; set; }

    /// <summary>
    /// A template that will be used to represent the options.
    /// </summary>
    /// <remarks>
    /// When <c>null</c> <see cref="TValue.ToString()"/> will be used to represent the item.
    /// </remarks>
    [Parameter]
    public RenderFragment<TValue>? ItemTemplate { get; set; }

    protected override string ClassNames => BuildClassNames(Class, (ExtendedBootstrapClass.FormFloating, true));

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        if (Values.Any(v => v is null))
        {
            throw new ArgumentNullException(nameof(Values), $"null values aren't allowed in {nameof(Values)}");
        }

        if (!DisabledValues.All(v => Values.Contains(v)))
        {
            throw new InvalidOperationException($"Every value of {nameof(DisabledValues)} have to be contained in {nameof(Values)}.");
        }

        if (Value is null && DefaultTemplate is null)
        {
            Value = Values.First();
        }

        IdSelector ??= value => value!.ToString()!;
    }

    private async Task OnSelectionChangedAsync(ChangeEventArgs e)
    {
        string valueId = (string)e.Value!;

        TValue? newValue = Values.FirstOrDefault(value => IdSelector(value).Equals(valueId));
        if (newValue is null)
        {
            throw new KeyNotFoundException($"Unable to find item with id {valueId}.");
        }

        Value = newValue;
        await ValueChangedAsync();
    }
}
